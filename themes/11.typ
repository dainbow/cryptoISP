#import "../conf.typ": *

= Конкретный пример стойкости

#note[
  Определим IND-CPA-стойкость криптосистемы с секретным ключом -- стойкость относительно пары угрозы 4/атака 3.

  Формализуем предположения о противнике с помощью специального оракула, к которому имеет доступ алгоритм противника.

  Оракул $cal(O)$, определяемый для криптосистемы $(G, E, D)$:
  - В начале работы выбирает секретный ключ $k in_cal(G)_n K_n$
  - После этого принимает запросы двух типов:
    + $(1; x)$, где $x in M_n$ в ответ на который возвращает $E(1^n, k, x)$
    + $(2; y^0, y^1)$, где $y^0, y^1 in M_n$, получив который, проверяет, что $y^0$ и $y^1$ не появлялись ранее, выбирает случайный бит $b in_cal(U) {0, 1}$ и в зависимости от значения $b$ возвращает либо $E(1^n, k, y^0)$, либо $E(1^n, k, y^1)$.
  - Ответив на один запрос второго типа, завершает свою работу
]

#definition[
  Криптосистема $(G, E, D)$ называется *IND-CPA-стойкой*, если для любой п.в.м.Т. $A$ с вышеописанным оракулом $cal(O)$:
  #eq[
    $mu({A^cal(O) (1^n) = b}) <= 1 / 2 + negl(n)$
  ]
]

#example[
  Пусть $g$ -- псевдослучайный генератор, $g(BB^n) subset.eq BB^(q(n))$

  $m_1, ..., m_t in BB^n$ -- сообщения, причём $t dot n + 1 < q(n)$

  Участники обмениваются по защищённому каналу секретным ключом $k in_cal(U) BB^n$, причём $g(k) = g_1...g_t, g_i in BB^n$.

  Тогда для $1 <= i <= t$:
  - Шифрование -- $c_i = E(1^n, k, m_i) = m_i plus.circle g_i$
  - Дешифрование -- $D(1^n, k, c_i) = c_i plus.circle g_i$
]

#proposition[
  Если $g$ -- псевдослучайный генератор, то описанная выше криптосистема -- IND-CPA-стойкая.
]

#proof[
  Предположим, что существует такая п.в.м.Т. $A$, что для некоторого полинома $p$ и бесконечно многих $n$ $mu({A^cal(O) (1^n) = b}) > 1 / 2 + 1 / p(n)$.

  Построим п.в.м.Т. $S$, работающую на входе $(1^n, z), z in BB^q(n), z = z_1...z_t, z_i in BB^n$ следующим образом:
  + $S$ запускает машину $A$ на входе $1^n$ и берёт на себя роль оракула, делая xor с элементами $z$.
  + Вычисляет выход -- $S(1^n, z) = cases(1 quad A^S (1^n) = b, 0 quad A^s (1^n) != b)$
  Таким образом,
  - если $z = g(v_n)$, то по предположению $A$ вычисляет $b$ с вероятностью $> 1 / 2 + 1 / p(n)$
  - иначе $z = v_q(n)$ -- произвольная равномерная случайная величина, отгадывающая ответ с вероятностью подбрасывания монетки
  Получили, что $mu({S(1^n, g(v_n)) = 1}) - mu({S(1^n, v_q(n)) = 1}) > 1 / p(n)$, что противоречит с тем, что $g$ -- псевдослучайный генератор.
]
