#import "../conf.typ": *

= О трудных предикатах

#definition[
  Функция $BB^* -> BB$ называется *трудным предикатом* для функции $f: BB^* -> BB^*$, если
  - $b$ -- полиномиально вычислимая функция
  - #eq[
      $forall "п.в.м.Т." A : mu_(x in_cal(U) BB^n) ({A(1^n; f(x)) = b(x)}) < 1 / 2 + negl(n)$
    ]
]

#theorem("Гольдрайха-Левина")[
  Пусть $f$ -- односторонняя функция, определённая всюду и сохраняющая длину, и пусть для всех $x, r in BB^*: abs(x) = abs(r)$, определены функции
  #eq[
    $g(x, r) = (f(x), r) quad b(x, r) = plus.circle_(i = 1)^abs(x) x^[i]r^[i]$
  ]
  Тогда $b$ -- трудный предикат для функции $g$.
]

#proof[
  Предположим, что $b$ не является трудным предикатом для функции $g$.

  Это значит, что существуют полиномиальный вероятностный алгоритм $A$, полином $p$ и бесконечное множество $N subset.eq NN without {0}$ такие, что
  #eq[
    $forall n in N: epsilon(n) = mu({A(1^(2 n), f(x), r) = b(x, r)}) - 1 / 2 > 1 / p(n)$
  ]
  Пусть $n in N$ и $x in BB^n$. Положим
  #eq[
    $t(n, x) = mu({A(1^(2 n), f(x), r) = b(x, r)}) quad E_n = {x in BB^n | t(x) >= 1 / 2 + epsilon(n) / 2}$
  ]
  Тогда, заметив, что
  - $EE_x (t (n, x)) = epsilon(n) + 1 / 2$ -- по определению
  - Можно применить неравенство Чебышёва, так как $1 / 2 - epsilon(n) / 2 > 0$.
  #eq[
    $mu({t(x) < 1 / 2 + epsilon(n) / 2}) = mu({1 - t(x) > 1 / 2 - epsilon(n) / 2}) <= \
      (EE_x (
        1 - t(n, x)
      )) / (1 / 2 - epsilon(n) / 2) = (1 / 2 - epsilon(n)) / (1 / 2 - epsilon(n) / 2) = 1 - epsilon(n) / (1 - epsilon(n)) < 1 - epsilon(n)$
  ]
  Воспользовавшись отрицанием обеих частей неравенства, получим
  #eq[
    $mu(E_n) = mu({t(x) >= 1 / 2 + epsilon(n) / 2}) > epsilon(n) > 1 / p(n)$
  ]
  Для завершения доказательства теоремы достаточно построить полиномиальный вероятностный алгоритм $B$, определённый для всех $n$ и на $f(E_n)$, такой, что
  #eq[
    $mu({B(1^n, f(x)) = x}) >= 1 / poly(n)$
  ]
  Тогда этой вероятностью мы сможем оценить снизу вероятность угадать прообраз $f$, что будет противоречить односторонности $f$.

  Введём обозначение $e_i in BB^n$ -- вектор с единицей на $i$-м месте.

  Алгоритм $B$ на входе $(1^n, f(x))$, где $n in N$ и $x in E_n$, будет искать каждый бит $x^[i]$ отдельно. Для этого алгоритм $B$:
  - Выбирает случайные элементы $r_1, ..., r_pi(n) in_cal(U) BB^n$, где $pi$ -- некоторый полиномиальный параметр на $N$, принимающий лишь нечётные значения.
  - Для каждого $j in {1, ..., pi(n)}$ вычисляет биты $beta_j, rho_j$, являющиеся предполагаемыми значениями $b(x, r_j plus.circle e_i)$ и $b(x, r_j)$ соответственно
  - Выбирает в качестве предпологаемого значения $x^[i]$ бит, который встречается в последовательности $beta_j plus.circle rho_j; j in {1, ..., pi(n)}$ более $pi(n) / 2$ раз
  Очевидно, если $beta_j = b(x, r_j plus.circle e_i)$ и $rho_j = b(x, r_j)$ для более чем половины индексов $j in {1, ..., pi(n)}$, то $x^[i]$ будет найден правильно, так как
  #eq[
    $b(x, r_j plus.circle e_i) plus.circle b(x, r_j) = b(x, e_i) = x^[i]$
  ]
  Бит $beta_j$ вычисляется как $A(1^(2 n), f(x), r_j plus.circle e_i)$. Мы не получим нужную оценку вероятности успеха алгоритма $B$, если будем вычислять $rho_j$ как $A(1^(2 n), f(x), r_j)$. Вместо этого алгоритм пытается угадать значение $b(x, r_j)$ для всех $j$.

  Но если просто выбрать $rho_j in_cal(U) BB$, то вероятность того, что $rho_j = b(x, r_j)$ для всех $j in {1, ..., pi(n)}$ будет равна $1 / 2^pi(n)$, а эта величина при нужном для нас росте $pi(n)$ будет пренебрежимо малой, как функция от $n$. Чтобы обойти это препятствие, алгоритм $B$ делает некую грязь.
]

