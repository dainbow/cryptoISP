#import "../conf.typ": *

= О функциях с секретом

#definition[
  *Система вероятностного шифрования с открытым ключом* -- это тройка алгоритмов $(G, E, D)$:
  - Генератор ключей $algo G: G(1^n) = (k, hat(k))$ -- открытый и секретный ключи
  - Алгоритм шифрования $algo E: c = E(1^n, k, m)$
  - Алгоритм дешифрования $detAlgo D: m = D(1^n; k, hat(k), E(1^n, k, m))$
]

#note("Основные типы атак")[
  + Атака с известным окрытым ключом *KOA*:
    - Атака с известными шифртекстами *KCA*
    - Атака с известными открытыми текстами *KPA*
    - Атака с выбором открытых текстов *CPA*
  + Атака с выбором шифртекстов *CCA*
    - Может быть адаптивной или неадаптивной
]

#note("Основные типы угроз")[
  + Полное раскрытие
  + Извлечение открытого текста
  + Извлечение частичной информации об открытом тексте
  + Различие двух шифртекстов
]

#definition[
  $F$ называется *семейством функций с секретом*, если для него существует тройка алгоритмов $(Gamma, C, R)$, удовлетворяющих следующим условиям:
  + $algo  Gamma: Gamma(1^n) = (d, s)$, где $d$ -- описание функции из семейства, $s$ -- секрет для этой функции.
  + $detAlgo C: (d, C)$ -- генератор для семейства $F: C(1^n; d, x) = f_(n, d) (x)$
  + $detAlgo R$:
  #eq[
    $forall (d, s) in supp(Gamma(1^n)) : forall x in BB^l(n) : R(1^n, d, s, f_(n, d) (x)) = x' in f^(-1)_(n, d) (
        f_(n, d) (x)
      )$
  ]
  + Для любой $algo A$ задача обращения $f_(n, d) (x)$ вычислительно трудна.
]

#example("Семейство функций Рабина")[
  $PP_n$ -- множество простых чисел $p$ длины $n$ в двоичной записи, таких, что $p equiv 3 mod 4$.

  $N = p q; quad p != q; quad p,q in PP_n$. Где $N$ называется числом Блюма.

  Тогда
  - $Gamma: Gamma(1^n) = (N, (p, q))$
  - $C: f_(n, N) (x) = x^2 mod N$
  - $R: R(1^n, N, (p, q), z) = cases(plus.minus z^((p + 1) / 4) mod p, plus.minus z^((q + 1) / 4) mod q)$ при условии, что $z = x^2 mod N$.
]

#theorem[
  Если для любой $algo A$ при $p, q in_cal(U) PP_n$ задача факторизации их произведения вычислительно трудна:
  #eq[
    $mu({A(1^n; p q) in {p, q}}) = negl(n)$
  ]
  То ${f_(n, N)}$ -- семейство функций с секретом.
]

#proof[
  Предположим, что $exists algo A$ для которой:
  #eq[
    $epsilon (N) = mu({f_(n, N) (A (1^n; N, f_(n, N) (z))) = f_(n, N) (z)})$
  ]
  её вероятность успеха инвертирования $f_(n, N)$.

  Построим машину Тьюринга $S^A$ с оракулом $A$ для факторизации $N$.

  На входе $N$ машина $S$ выполняет следующие шаги:
  - Выбирается $z in_cal(U) ZZ_N^*$ и вычисляет $f_(n, N)$
  - Вычисляет $a = (N, f_(n, N) (z))$. Если $a != 1$, то выдаёт $(N / a, a)$ и останавливается
  - Иначе обращается к оракулу и вычисляет $z' = A(N, f_(n, N) (z))$
  - Вычисляет $b = (N, z + z')$ и выдаёт $(N / b, b)$ и останавливается.
  Почему это правильный алгоритм?

  Если на втором шаге $a != 1$, то получаем разложение $N = p q$ и радуемся.

  Иначе, рассмотрим случайную величину $z$, равномерно распределённую в $ZZ_N^*$. Вероятность успеха инвертирования $f_(n, N) (z)$ по определению машины $A$ равна $epsilon(N)$.

  Из определения семейства функций знаем, что существует ровно четыре возможных допустимых значений для $z'$.

  Без ограничения общности, можно считать, что $z'$ принадлежит множеству из двух корней ${z_1, N - z_1}$.

  Поскольку значение $z$ распределено равномерно на множестве всех четырёх прообразов $f_(n, N) (z)$, то с вероятностью $1 / 2$ элемент $z$ принадлежит другой паре ${z_2, N - z_2}$.

  Тогда
  #eq[
    $(z + z')(z - z') = z^2 - (z')^2 = 0$, но при этом БОО $z + z' != 0 mod N$
  ]
  Тогда по свойствам поля -- ${p, q} in.rev (z + z', N) != 1$.

  Следовательно, машина $S^A$ находит разложение числа $N$ на множители $p, q$ с вероятностью не менее $epsilon(N) / 2$, которая отделима от нуля каким-то полином на бесконечном подмножестве $NN$ -- противоречие.
]
