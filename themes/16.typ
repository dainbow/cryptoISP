#import "../conf.typ": *

= О криптографических хеш-функций

#definition[
  *Семейством хэш-функций* называется
  #eq[
    $H = union_(n in NN) H_n = {h_(n, i): BB^t(n) -> BB^m(n)}_(n in NN, i in I_n)$
  ]
  где $t(dot), m(dot)$ -- такие полиномы, что $m(n) < t(n)$ для всех $n in NN$, а на каждом случайном векторе $I_n$ задано распределение вероятностей $cal(I)_n$, так, что ${cal(I)_n}_(n in NN)$ -- полиномиально конструируемое семейство.
]

#definition[
  $H$ называется *семейством хэш-функций с труднообнаружимыми коллизиями* относительно ${cal(I)_n}_(n in NN)$, если
  - $H$ -- полиномиально вычислимо
  - Для любой $algo A$
  #eq[
    $mu_(i <- cal(I)_n) ({A(1^n; i) = (x', x''), x' != x'', h_(n, i)(x') = h_(n, i) (x'')}) = negl(n)$
  ]
]

#definition[
  $H$ называется *(универсальным) односторонним семейством хэш-функций* относительно ${cal(I)_n}_(n in NN)$, если
  - $H$ полиномиально вычислимо
  - Для любой такой $algo A$, которая сначала на входе $1^n$ выдаёт $x' in BB^t(n)$, а затем на входе $i in I_n$ выдаёт $x'' in BB^t(n)$ ($A$ реализует алгоритм поиска специфичных колизий)
  #eq[
    $mu_(i <- cal(I)_n) ({A(1^n; i) = x'', x'' != x', h_(n, i) (x') = h_(n, i) (x'')}) = negl(n)$
  ]
]

#theorem("Наора-Юнга")[
  Если существует односторонняя перестановка, то существует и одностороннее семейство хэш-функций.
]

#proof[
  Отождествим $BB^n$ с $GG FF (2^n)$ для каждого $n$. (все рассматриваемые алгебраические операции над векторами будут иметься в виду именно из этого поля).

  Пусть
  #eq[
    $G_n := {
        forall a, b in BB^n : a != 0 | g_(n, a, b) : BB^n -> BB^(n - 1) : g_(n, a, b) (x) = (a x + b)^[1, ..., n - 1]
      }$
  ]
  Заметим, что строки $x', x''$ образуют коллизию для $g_(n, a, b)$ тогда и только тогда, когда $g_(n, a, b) (x'), g_(n, a, b) (x'')$ различаются только в последнем бите.
  #eq[
    $a x' + b = a x'' + b + 1 => a = (x' - x'')^(-1)$
  ]
  Пусть $M(x', x'') = ((x' - x'')^(-1), r)$, где $x', x'' in BB^n, r in_cal(U) BB^n$.

  По сути $M$ по двум элементам выдаёт индекс хэш-функции из $G_n$, на которой на них будет коллизия.

  Тогда $M$ удовлетворяет свойству достижимости коллизий.

  Кроме того, поскольку $(x' - v)^(-1) in_cal(U) BB^n without {0}$ при $v in_cal(U) BB^n without {x'}$, случайная величина $M(x', v)$ распределена равномерно на множестве описаний всех функций из $G_n$.

  Пусть предполагаемая существуюшая односторонняя перестановка -- $f$. Рассмотрим семейство
  #eq[
    $H = union_(n in NN) H_n = union_(n in NN) {h_(n, a, b) = g_(n, a, b) compose f | g_(n, a, b) in G_n}$
  ]
  Очевидно, оно полиномиально вычислимо, как состоящее из композиций полиномиально вычислимых функций.

  Докажем, что задача поиска специфических коллизий для него трудна.

  Пусть произвольная $algo A$, реализующая алгоритм поиска специфических коллизий для семейства хэш-функций $H$.

  Напомним, что $algo A$ работает в два этапа:
  - На первом по случайному вектору $1^n$ выдаёт $x$, к которому на втором этапе будем искать коллизию
  - На втором этапе $A(1^n; v)$ выдаёт $x'$, который должен выдавать коллизию с $x$ на хэш-функции $h_(n, v)$. В этом конкретном случае $v = (a, b)$.

  На основе $A$ построим вспомогательную $algo B$, которая будет дальше применена в доказательстве.

  Алгоритм $B$ будет принимать на вход $v in BB^n$. (Хотим построить $B$ так, чтобы $B(1^n; f(v)) = v$).

  - Если $f(x) = v$, где $x$ из описания первого этапа $A$, то $B$ вернёт $x$
  - Иначе $B$ вернёт результат выполнения $y = A(1^n; M(f(x), v))$, то есть элемент, который имеет коллизию с $x$ на такой хэш-функции, в которой имеют коллизию элементы $f(x)$ и $v$.
  Очевидно, $B$ полиномиальна.

  Предположим, что для поданной на вход машине $B$ строки $f(u), u in BB^n$ выполнено
  - $f(x) != v = f(u)$
  - $y != x$
  - $h_(n, a, b) (y) = h_(n, a, b) (x)$, где $(a, b) = M(f(x), f(u))$
  Из этого случая можно сделать следующие выводы:
  - $f(x) != f(y)$, так как $f$ перестановка и $x != y$.
  - $g_(n, a, b) (f(y)) = h_(n, a, b) (y) = h_(n, a, b) (x) = g_(n, a, b) (f(x))$ по предположению
  - Но при этом $g_(n, a, b) (f(x)) = g_(n, a, b) (f(u))$, так как по определению $M$ для функции с индексов $(a, b) = M(f(x), v)$ пара $(f(x), v) = (f(x), f(u))$ образует коллизию.
  Итого $f(y) != f(x) != f(u)$, но при этом $g_(n, a, b) (f(y)) = g_(n, a, b) (f(x)) = g_(n, a, b) (f(u))$.

  Следовательно, $f(y) = f(u)$, так как у $g_(n, a, b) (f(x))$ не может быть три различных прообраза.

  Следовательно $y = u$, так как $f$ -- перестановка $=>$ на входе $f(u)$ машина $B$ выдаёт $u$.

  Теперь используя эту $algo B$ с доказанным свойством докажем сложность произвольного алгоритма поиска специфических коллизий для семейства хэш-функций $H$.

  Пусть $x$ -- выход $A$ после 1 этапа, $(a, b) in_cal(U) (BB^n without {0^n}) times BB^n$/

  Заметим, что $u in_cal(U) BB^n without {x} <=> f(u) in_cal(U) BB^n without {f(x)}$.

  Наконец, мы готовы совершить оценку сложности поиска коллизий
  #eq[
    $mu_((a, b)) ({A(1^n; (a, b)) = y, y != x, h_(n, a, b) (y) = h_(n, a, b) (x)}) = \
      mu_u ({A(1^n; M(f(x), f(y))) = y, y != x, h_(n, a, b) (x) = h_(n, a, b) (y)}) <= \
      mu_v_n ({B(1^n; f(v_n)) = v_n | f(x) != f(v_n)}) <= (mu_v_n ({B(1^n; f(v_n)) = v_n})) / (mu_v_n (
        {f(x) != f(v_n)}
      )) <= 2 negl(n)$
  ]
  В последнем переходе мы воспользовались тем, что $mu_v_n ({f(x) != f(v_n)}) = 1 - 1 / 2^n >= 1 / 2$ и тем, что $f$ -- односторонняя перестановка.
]
